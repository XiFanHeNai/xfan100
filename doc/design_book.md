# XFAN100设计日志

[TOC]

## 开始，准备

###环境

开始设计之前，我们需要准备一些看似无关紧要的东西。比如搭台唱戏，搭台子永远排在唱戏前面。此处，我们首先着手准备环境。此处有两个要素：

- 编译工具：任何高级代码，包括汇编代码，都需要一套工具，将其转换成CPU能识别的二进制文件，而这套工具就是编译工具。此处我们使用已有的工具来避免精力的分散。所谓集中力量办大事。最终的工具选择芯来科技官方网站上的工具链，当然是Ubuntu版本的。
- 测试用例：也即是我们用于验证CPU的“工具”，所谓是骡子是马得牵出来溜溜。这些基本的测试用例可以保证我们不会出现一些非常低级明显的错误。此处，我们还是选择芯来科技开源版本的蜂鸟项目里所包含的测试用例。在Github上搜索相关关键字可找到。



### 第一个模块：TestBench

testbench，是一个系统的最顶层部分，负责一系列激励信号的产生，包括系统时钟，复位信号以及内存的初始化。对于一个简化的系统，这三部分缺一不可。本部分主要包含三个文件：

- tb_top.v文件：tb顶层文件，主要完成如下任务：
  - 控制仿真的结束时间。
  - 收集并产生波形数据。
  - 产生全局时钟和复位信号.
  - 例化存储器初始化模块。
- tb_mem_init.v文件：存储器初始化模块。
- tb_defines.v文件：上述两个文件所使用的宏的定义。注意**本文件中的宏只允许出现在tb模块中**,如果在其他下层模块中有使用到相同的宏，则需要重新定义。此举是为了**保证各个层级之间宏定义有清晰的边界，便于后续层级划分**。

### 编译一下

编译并仿真我们写好的程序，需要用到几个专用的工具。此处我们采用Synposys和谐版的代码仿真编译与波形查看工具：VCS和Verdi。根据这两个工具的使用语法，可以分析出我们需要如下配件

- rtl文件所在的路径
- 所有使用到的rtl文件的列表

此外，由于我们还需要查看波形文件，而波形文件的产生需要用到某些系统函数，例如**$fsdbDumpfile()**等，这些系统函数需要库的支持。因此在VCS进行编译之前，其参数需要添加以下两行：

```makefile
-P your_verdi_install/share/PLI/VCS/LINUX64/novas.tab \
   your_verdi_install/share/PLI/VCS/LINUX64/pli.a	\
```

在调用verdi工具进行调试时，需要指定：

- rtl文件所在的路径
- 所有使用到的rtl文件列表
- 顶层实例化名称，此处为tb_top
- 生成好的波形文件（此处为*tb_top.fsdb*文件）

在终端运行以下命令，进行编译与仿真：

```shell
make run_test
```

在终端运行以下命令，查看波形并进行调试：

```shell
make wave
```

至此，就可以看到，随着时间的增加，mem_init模块将其内部初始化的数据依次取出。在外界形式上看来，就是一条一条的指令，按次序输出到我们指定的模块。

## 第一条指令

我们首先实现一条最简单的**加法指令**，以此介绍处理器设计过程中一些常用的方法策略，同时逐步解释具体的代码在C处理器中执行的过程。借此对处理器形成一个全面的认知。

从上一部分生成的测试样例的*.dump*文件中，我们找到了如下内容：

```txt
80000266:	00208f33          	add	t5,ra,sp
```

上面的内容截取自*add.dump*文件，主要包含三个部分：

- PC地址：在上例中是*0x80000266*,该地址表明当前指令存储的位置。这个位置并不是在存储器中的地址，而是在总线系统中的地址。一般来讲，存储器在总线中有一个基地址，这个基地址是由编译过程中的链接文件指定的。然后编译器会计算出某些代码块的相对地址，这两个地址的和，才是最终该指令在总线系统中的地址。
  - 在当前的设计中，由于我们仅仅关注某一条指令在流水线中的具体执行过程，因此并不关心其PC地址的值。故在具体的仿真波形中，该信号是一个未知信号。（**TODO**）
- 指令编码：在上例中是*0x00208f33*。指令编码包含当前指令的所有基本信息，包括：
  - 具体操作指令，是算术运算，还是访存等
  - 是否需要读取源操作数寄存器以及写回到目的操作数寄存器
		具体的汇编伪码：在上例中是 *add	t5,ra,sp* 

下面以具体讲述该指令的实现过程，代码详情请参考[rtl](xf100/rtl/)。

### 流水线的起点，取指

为保证流水线的执行速率，一般来讲指令都是存储在速度最快的存储器，例如RAM中的。取指模块的作用就是按需将这些指令取出来交给执行单元执行。此处，由于我们仅关注单个指令的执行过程，并不关心取指过程中的诸如分支预测，PC计算等操作，只是模拟指令从取指模块出去之后的一系列执行过程。因此目前取指模块基本上是一个空模块。详情请参见[xf100_ifu](xf100/rtl/core/ifu/xf100_ifu.v)。【接口，波形】

### 确认身份，译码

译码模块，负责解码取指模块送过来的指令码所包含的具体信息，这些信息包括：

- 当前指令是否是一个非法指令

- 当前指令码所属的操作类型以及具体的操作
- 当前指令是否需要读取源操作数寄存器，是否需要写回目的操作数寄存器

如果当前指令是一个未定义的非法指令，意味着需要产生异常，调用异常处理程序。如果当前指令码需要源操作数和目的操作数，则需要从寄存器文件(regfile)模块中读出相应的源操作数，并给出是否需要写回目的操作数的标志。其接口如下，具体代码请参考[xf100_exu_decode](xf100/rtl/core/exu/xf100_exu_decode.v)。【波形】

```verilog
module xf100_exu_decode 
(
    input [`XF100_INSTR_SIZE-1:0] dec_i_instr, // 输入的指令码

    output dec_o_alu_op  , // 当前指令码是否属于算术运算类型(ALU)
    output [`ALU_INFO_WIDTH-1:0] dec_o_alu_info,//当前指令码的具体操作，one-hot信号组
    output dec_o_rs1_en,// 当前指令码是否需要源操作数1
    output dec_o_rs2_en,// 当前指令码是否需要源操作数2
    output dec_o_rd_en ,// 当前指令码是否需要目的操作数
    output [`XF100_RFIDX_WIDTH-1:0]  dec_o_rs1_idx,//当前指令源操作数1的编号
    output [`XF100_RFIDX_WIDTH-1:0]  dec_o_rs2_idx,//当前指令源操作数2的编号
    output [`XF100_RFIDX_WIDTH-1:0]  dec_o_rd_idx ,//当前指令目的操作数的编号

  // 译码模块属于纯组合逻辑电路，不需要复位信号以及时钟信号，因此这两个信号在此并不起作用，属于占位符。
  input clk,
  input rst_n
);
```

### 预备操作数

操作数是存储在寄存器文件里的，由32个寄存器（目前设计只支持32bit指令集，因此其寄存器数目固定为32）组成。因此写寄存器在下一拍生效，读寄存器采用max设计，在当拍生效。此外，根据当前设计需求，我们仅仅实现一条简单的加法指令，因此只需要实现一个写回端口。但是由于其有两个源操作数，需要同时读两个不同的寄存器，因此需要两个读端口。其接口如下，具体代码请参考[xf100_exu_regfile](xf100/rtl/core/exu/xf100_exu_regfile.v)。【波形】

```verilog
module xf100_exu_regfile 
(
    // read port
    input                            rf_i_read_en1,//读寄存器1使能
    input [`XF100_RFIDX_WIDTH-1:0]   rf_i_read_rsidx1,//寄存器1的读编号
    output [`XF100_XLEN-1:0]         rf_o_read_data1,//寄存器1的读数据

    input                            rf_i_read_en2,//读寄存器2使能
    input  [`XF100_RFIDX_WIDTH-1:0]  rf_i_read_rsidx2,//寄存器2的读编号
    output [`XF100_XLEN-1:0]         rf_o_read_data2,//寄存器2的读数据

    //write port
    input                            rf_i_wr_en,//寄存器的写使能
    input [`XF100_XLEN-1:0]          rf_i_wr_data,//寄存器1写数据
    input [`XF100_RFIDX_WIDTH-1:0]   rf_i_wr_rdidx,//寄存器1写编号

    input clk,// 寄存器的时钟信号，当前接的是系统时钟
    input rst_n// 寄存器的复位信号，当前接的是系统复位，低电平有效
);
```



### 执行命令

执行模块负责具体指令的执行操作，比如在本例中，加法的执行部分就在此模块中。当所有的数据准备好时，就可以执行指令操作了。执行模块的接口如下，具体代码请参考[xf100_exu_alul](xf100/rtl/core/exu/xf100_exu_alu.v)。【波形】

```verilog
module xf100_exu_alu 
(
    input                       alu_i_alu_op  ,//指令的操作类型，与info信息同时用于解码出具体操作
    input [`ALU_INFO_WIDTH-1:0] alu_i_alu_info,
    input                           alu_i_rs1_en,// 当前指令是否需要源操作数1，目前未使用
    input                           alu_i_rs2_en,// 当前指令是否需要源操作数2，目前未使用
    input                           alu_i_rd_en ,// 当前指令是否需要写回目的操作数
    input [`XF100_XLEN-1:0]         alu_i_rs1,//当前指令的源操作数1的值
    input [`XF100_XLEN-1:0]         alu_i_rs2,//当前指令的源操作数2的值
    input [`XF100_RFIDX_WIDTH-1:0]  alu_i_rdidx,//当前指令的目的操作数编号

    output                           alu_o_wbck_en,//当前操作的写回使能信号
    output [`XF100_XLEN-1:0]         alu_o_wbck_data,//当前操作需要写回的数据
    output [`XF100_RFIDX_WIDTH-1:0]  alu_o_wbck_rdidx,//当前操作需要写回的寄存器的编号

    // 占位符
    input clk,
    input rst_n

);
```

当具体的代码执行完后，其结果会通过写回端口输出到写回控制模块。

### 写回控制

写回是一条指令最后的一个步骤，当指令执行完毕，如果需要将结果写回，就会使能写回控制信号，将结果写回到寄存器文件中供下一条指令使用。此外，写回控制还涉及到仲裁的问题，不过在当前设计中，由于我们只实现了一条指令，因此不存在仲裁问题。写回模块的接口定义如下，具体代码参见[xf100_exu_wbck](xf100/rtl/core/exu/xf100_exu_wbck.v)。【波形】

```verilog
module xf100_exu_wbck 
(
    input                           wbck_i_wbck_en,//当前操作是否需要写回
    input [`XF100_XLEN-1:0]         wbck_i_wbck_data,//需要写回的数据
    input [`XF100_RFIDX_WIDTH-1:0]  wbck_i_wbck_rdidx,//具体要写回的寄存器编号

    output                          wbck_o_wbck_en,//寄存器写使能信号
    output [`XF100_XLEN-1:0]        wbck_o_wbck_data,//需要写回到寄存器文件的数据
    output [`XF100_RFIDX_WIDTH-1:0] wbck_o_wbck_rdidx,//具体要写回的寄存器编号

    // 占位符
    input clk,
    input rst_n
);

```

总的来讲，一条指令的执行，离不开**取指**、**译码**、**执行**、**写回**这几个步骤，以上就是对这几个步骤的详细介绍。当然对于需要访问存储的指令，例如*加载指令*和*存储指令*，还有一步是访存操作。但这不在当前我们设计的这个样例中，因此也没有做过多介绍。本例中，加法执行成功的标志，是相关结果被正确写回到对应的寄存器中。

执行编译运行命令之后，会看到如下波形：

