# XFAN100设计日志

[TOC]

## 开始，准备

###环境

开始设计之前，我们需要准备一些看似无关紧要的东西。比如搭台唱戏，搭台子永远排在唱戏前面。此处，我们首先着手准备环境。此处有两个要素：

- 编译工具：任何高级代码，包括汇编代码，都需要一套工具，将其转换成CPU能识别的二进制文件，而这套工具就是编译工具。此处我们使用已有的工具来避免精力的分散。所谓集中力量办大事。最终的工具选择芯来科技官方网站上的工具链，当然是Ubuntu版本的。
- 测试用例：也即是我们用于验证CPU的“工具”，所谓是骡子是马得牵出来溜溜。这些基本的测试用例可以保证我们不会出现一些非常低级明显的错误。此处，我们还是选择芯来科技开源版本的蜂鸟项目里所包含的测试用例。在Github上搜索相关关键字可找到。



### 第一个模块：TestBench

testbench，是一个系统的最顶层部分，负责一系列激励信号的产生，包括系统时钟，复位信号以及内存的初始化。对于一个简化的系统，这三部分缺一不可。本部分主要包含三个文件：

- tb_top.v文件：tb顶层文件，主要完成如下任务：
  - 控制仿真的结束时间。
  - 收集并产生波形数据。
  - 产生全局时钟和复位信号.
  - 例化存储器初始化模块。
- tb_mem_init.v文件：存储器初始化模块。
- tb_defines.v文件：上述两个文件所使用的宏的定义。注意**本文件中的宏只允许出现在tb模块中**,如果在其他下层模块中有使用到相同的宏，则需要重新定义。此举是为了**保证各个层级之间宏定义有清晰的边界，便于后续层级划分**。

### 编译一下

编译并仿真我们写好的程序，需要用到几个专用的工具。此处我们采用Synposys和谐版的代码仿真编译与波形查看工具：VCS和Verdi。根据这两个工具的使用语法，可以分析出我们需要如下配件

- rtl文件所在的路径
- 所有使用到的rtl文件的列表

此外，由于我们还需要查看波形文件，而波形文件的产生需要用到某些系统函数，例如**$fsdbDumpfile()**等，这些系统函数需要库的支持。因此在VCS进行编译之前，其参数需要添加以下两行：

```makefile
-P your_verdi_install/share/PLI/VCS/LINUX64/novas.tab \
   your_verdi_install/share/PLI/VCS/LINUX64/pli.a	\
```

在调用verdi工具进行调试时，需要制定：

- rtl文件所在的路径
- 所有使用到的rtl文件列表
- 顶层实例化名称，此处为tb_top
- 生成好的波形文件（此处为*tb_top.fsdb*文件）

在终端运行以下命令，进行编译与仿真：

```shell
make run_test
```

在终端运行以下命令，查看波形并进行调试：

```shell
make wave
```

至此，就可以看到，随着时间的增加，mem_init模块将其内部初始化的数据依次取出。在外界形式上看来，就是一条一条的指令，按次序输出到我们指定的模块。

### 流水线的起点，取指



